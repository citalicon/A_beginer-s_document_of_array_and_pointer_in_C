## 关于C语言的指针和数组

*© 2025 by [某科学的都市传说](https://space.bilibili.com/446268660) is licensed under [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/).*

本文成文的主要原因是作者在试图弄明白C中关于指针和数组混乱的定义与使用方式的过程中绕了很多圈子。当然作为*中级* 语言为了减少代码量简并一些语法是无可厚非的。本文试图澄清这些规则。  

如果你认为自己没有遇到这种混乱，那么请试着解释一下下面这个声明

`int *(*p[2])[2];`然后试着给它赋值。  

那么我们开始讲。

本文默认只讨论int类型及其衍生。

### 可能用到的术语

读者可以先略读一遍，等后面遇到再来找。本文使用不同的术语翻译是出于直觉和语言通顺上的考虑。

| 术语                           | 翻译                     |
| ------------------------------ | ------------------------ |
| int                            | 整型                     |
| array                          | 数组                     |
| matrix (array of array)        | 矩阵、数组组、二维数组   |
| tensor (multi-dimention array) | 张量、高维数组           |
| pointer                        | 指针                     |
| pointer to *sometype*          | 指向*sometype*的指针     |
| array of *sometype*            | 以*sometype*为元素的数组 |
| pointer to array               | 数组指针[^0]             |
| array of pointer               | 指针数组[^1]             |
| &, ampersand, address of       | 取地址、...的地址        |
| *, dereference, star, "星"     | 解引用[^2]               |
| value,值                       | 指针所指向的变量的值[^3] |

---

### 指针是什么、数组是什么

> 指针是一个变量，它的值是它所指向的变量的地址。

这大概是每本教科书都会传递给学生的定义。 

**但是**指针事实上还有另一种内涵，即**指针所指向的变量的类型**。例如，作为这种内涵的一项特征，指针还描述了这个被指变量所占用的内存大小。例如：

```c
int (*pta)[2];//"pta" means pointer_to_array
```

如果读者不理解这个声明（以及下面的赋值操作）是什么意思，请先不要急，我们后面会把这个问题拿出来讨论。我们就此首先解释这个声明的含义，即： 

**pta是一个指针，他指向了一个长度为2的数组，这个数组的元素是一个整型。** 

于是我们就能看到，pta这个指针有下面两个内涵：它所指向的变量的地址与这个变量的类型。在上面这个例子里面，这个变量的类型是*一个数组，这个数组的元素是整型，长度是2*。它所指向的地址目前还是随机的。我们可以通过下面的赋值语句让它指向一个固定的变量。

```c
int arr[2] = {0,1};//初始化arr
pta = &arr;
```

所以我们现在给出指针的定义：

> 指针是这样两个东西的集合：
>
> 1. 指针这个变量所存储的值，即它所指向的变量的地址；
> 2. 指针所指向的变量的类型。

所以，下文中： 

我们在说 *一个指针的类型* 的时候，我们其实在说这个指针所指向的变量的类型，我们也称这个指针为*sometype*指针。 

同样，我们在说两个指针的类型 *相同* 的时候，我们其实在说他们所指向的变量的类型相同。

---

好。那么数组arr是什么？

> 数组是一个类型，它是它的元素组成的集合，这些元素的类型都是**相同**的。[^4]

我们看到，数组的定义里完全没有，根本没有出现指针的影子。数组是一个非常纯粹的、独立（为了纠正一些观点，需要在这里特别强调，独立于指针）存在的变量类型。

> 二维数组是一个数组，它的元素是一个一维数组。

我们可以类似递推地定义张量。我们依然没有看见任何指针的痕迹。

举个例子：

```c
int mtr[3][3] = {
	{1,2,3},
	{4,5,6},
	{7,8,9}
};
```

我们可以通过取下标操作对数组元素进行访问。换句话说，我们把一个数组和一个`size_t`类型的变量传入了一个函数，然后得到了这个数组的元素。

```c
mtr[0];//{1,2,3}
```

 

由于后文会提到的原因，`mtr[i]`和`i[mtr]`是一样的，读者可以暂时将其理解为一种函数自带的规则。

---

#### 取地址符&

我们可以把用取地址符得到的东西赋给这样一个指针：它指向被取地址的变量、它的类型（注意，我们这里在谈论的是一个指针的类型）是被取地址的变量的类型。

例如: 

```c
int (*ptm)[3][3];
ptm = &mtr;
```

---

### 变量的声明

> [C gibberish ↔ English](https://cdecl.org/)

>  一个指针和数组嵌套组成的变量声明的形式如下：
>
> int、m个*、变量名称、n个[] ;（省略了可能存在的括号）
>
> 其中从变量开始按某个顺序和*与[]结合。

这样讲过于抽象了，而且表述可能不够准确。我们从例子入手：

```c
int (*(*(*p)[m])[n][p])[q];
```

声明的阅读原则：

> 1. p是一个对象。
>2. 一个对象首先结合的运算符是这个对象的类型。
> 3. []结合对象的优先级高于*。
>4. 有括号先结合括号里的。
> 5. 把某个对象与*或[]结合后的产物视作一个新的对象（称为产物对象）。
> 6. *对象 的意思是，对象是一个指针，指向产物对象，指针类型是产物对象的类型。
>7. 对象[x] 的意思是，对象是一个有x个元素的数组，数组元素的类型是产物对象的类型。
> 8. 最后被结合的运算符的元素类型或指针类型是int。
>
> ex.  考虑函数指针的话，结合优先级为[]=()>*,对象()的意思是，对象是一个函数，返回值的类型是产物对象的类型。

而在此我们会经历如下步骤：

> 1. p是一个指针，它指向：
>
> 2. 一个长度为m的数组，这个数组的元素是：
>
> 3. 一个指针，这个指针指向：
>
> 4. 一个长度为n的数组，这个数组的元素是：
>
> 5. 一个长度为p的数组，这个数组的元素是：
>
>    > 4.和5.也可以写成下面这样。
>    >
>    > 4&5.一个n*p的矩阵，这个矩阵的元素是：
>
> 6. 一个指针，它指向：
>
> 7. 一个长度为q的数组，这个数组的元素是：
>
> 8. 整型。

> 读者当然也可以以相反方式从外往内拆括号，这时*是优先于[]的。

这样我们就很容易能理解下面这些常见声明的含义了。

```c
int (*ptr)[3];		//数组指针
int *arr[3];		//指针组
int *mtr[3][3];		//指针矩阵
int (*mtr[3])[3];	//指针组，每个指针指向一个数组
```

### 变量的赋值

赋值用等号连接。

#### 指针的赋值

我们可以使指针p指向变量v，其中指针的类型和变量的类型应当是相同的。

```c
int (*p)[3];
int mtr[3][3] = {1,2,3,4,5,6,7,8,9};
p = &mtr[0];	//[]运算符优先于&
```

#### 数组的赋值

我们只能在初始化时给数组赋值，或者分项写入数组元素。

```c
int tsr[2][2][2] = {1,2,3,4,5,6,7,8};
int (*mtr[2])[2][2] = {&tsr[0],&tsr[1]};
```

#### 关于指针赋值语法的澄清

声明语句

```c
int n;
int *p = &n;
```

事实上是不符合直觉的，因为事实上`*p == n`而`p == &n`。我们应该首先把第二行定义成以下两个语句的简化。

```c
int *p;
p = &n;
```

在写带赋值的指针的声明语句的时候，我们应当首先通过变量的声明语法确定它的类型，再写对一个对以这个指针类型为类型的变量取地址的语句，然后把它们用`=`连接。

##### 事实上的赋值

请参阅[声明](https://en.cppreference.com/w/cpp/language/declarations.html)以及[初始化](https://en.cppreference.com/w/cpp/language/declarations.html)。上面所说的“定义成”事实应该说成“理解成”，一个简单的例子就是我们可以在函数体外部“带有显式的初始化地声明”一个变量，但**不能**先“隐式初始化”再“赋值”。

---

### 隐式类型转换

先考虑如下(1)(2)两条语句。

```c
int tsr[2][2][2] = {1,2,3,4,5,6,7,8};
int (*p1)[2][2][2] = &tsr;		//(1)
int (*p2)[2][2] = tsr;				//(2)
```

(1)是符合我们上述所讲的规范的。tsr是个三维张量而p1是一个指向这个张量的数组（通过对tsr的&运算）。(2)则不符合。等式左边声明p2是一个指针，指向一个2*2的矩阵，而右边则是一个张量类型。

赋值行为之所以合法**是因为c编译器将数组自动转换为了指向这个数组的第一个元素的指针**即`&tsr[0]`，而此时赋值语句两边的类型是一致的。而编译器在这种情况下又并**不会**将仍然作为数组的`tsr[0]`**再次**隐式类型**转换**为`&tsr[0][0]`[^5]，也就是说，在这里隐式类型转换只在最外层发生。在(1)中则没有发生隐式类型转换[^5]。

#### 指针的运算与数组的取下标操作

指针可以进行加减法操作。

```c
int mtr[3][3] = {1,2,3,4,5,6,7,8,9};	// 声明告诉我们(编译器)，`matrix`的元素类型是int[3]即4*3=12个字节。
int (*p)[3] = mtr;										//p == &mtr[0]
p+1;																		//&mtr[1]
```

对指针+n会使指针的值向后移n个指针类型的大小个字节。 

我们可以通过这种方法重新看待数组的取下标操作，并将`mtr[i]`重新定义为`*(mtr+i)`[^6]。即： 

`mtr[0] == *(mtr+1)`。

这样我们就能解释为什么`mtr[i]`和`i[mtr]`是一致的，因为指针的加法是交换的。

我们能采用同样的定义对指针进行取下标操作，不过请注意不要越界。

**请注意这种操作和声明变量时的[]的用法不可混同，后者是在划定数组(以及子数组)的大小。**

#### 向函数传递数组的两种方式

既然数组没法作为函数的形参，一个最符合直觉的向函数传递数组的方式就是传递一个指向这个数组的指针，即：

```c
void foo(int (*p)[3]){
	;
}
int main(){
  int arr = {1,2,3};
  int (*p)[3] = &arr;
  foo(p);
  return 0;
}
```

没有问题。唯一的缺点是我们每次在foo中访问arr的元素时都需要写`(*p)[i]`。**很不好写**。这就是为什么在绝大多数教科书上我们都没有看见这种写法。

大部分情况下，我们看到的是这种写法： 

```c
void foo(int *p,int len){
	;
}
int main(){
  int arr = {1,2,3};
  int *p = &arr[0];
  foo(p,3);//事实上我们可以不管p直接写foo(arr)；
  return 0;
}
```

这时我们传入了一个 *被隐式类型转换成的* 整型指针，在我们希望在`foo`中访问arr的元素时，我们可以**好像arr是一个数组那样访问，这是因为我们在把数组传入函数时提前做了隐式类型转换**，因此步骤`arr[i]`(=`*(arr+1)`)不再需要转换。这种写法的一个结果是我们要通过向`foo`另外传入一个变量`int len`来得知`arr`的长度。第一种方法的`sizeof(*p)`是有效的。

读到这里的读者应该能独立想出指针组为什么可以用以表示长度不同的数组之组了。

---

### END

Special thanks to [蔬菜](https://space.bilibili.com/518350872).

---

[^0]: 一个指针，它指向一个（一般而言是一维的）数组。
[^1]: 直觉起见，我其实更倾向于把它读成**指针数-组**而非**指针-数组**，或者也可以直接叫指针组。
[^2]: 一个指针才能被解引用，得到它所指向的变量。
[^3]: 值不一定是数（整型）。我们解引用一个指针就能得到它的值。例如一个数组指针的值就是一个（具体的）数组。
[^4]: 如果学过用指针数组表示有长度不同数组作为元素的数组组的同学对此有疑惑，我们会在后面解释这件事。在这里相同的类型是一个 *被隐式类型转换成的整型指针* 。
[^5]: &&是非法的
[^6]: 注意此处`mtr`发生了隐式类型转换。
